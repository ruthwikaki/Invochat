
-- MIGRATION SCRIPT: Add billing and subscription fields
-- This script is designed to be run once on your existing database.

-- Add a new ENUM type for subscription status if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_status') THEN
        CREATE TYPE public.subscription_status AS ENUM (
            'trialing',
            'active',
            'past_due',
            'canceled'
        );
    END IF;
END
$$;

-- Add a new ENUM type for subscription plan if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_plan') THEN
        CREATE TYPE public.subscription_plan AS ENUM (
            'starter',
            'growth',
            'enterprise'
        );
    END IF;
END
$$;


-- Add new columns to the company_settings table
ALTER TABLE public.company_settings
    ADD COLUMN IF NOT EXISTS subscription_status public.subscription_status DEFAULT 'trialing',
    ADD COLUMN IF NOT EXISTS subscription_plan public.subscription_plan DEFAULT 'starter',
    ADD COLUMN IF NOT EXISTS subscription_expires_at timestamptz,
    ADD COLUMN IF NOT EXISTS stripe_customer_id text,
    ADD COLUMN IF NOT EXISTS stripe_subscription_id text,
    ADD COLUMN IF NOT EXISTS usage_limits jsonb,
    ADD COLUMN IF NOT EXISTS current_usage jsonb;

-- Add a comment to the table for clarity
COMMENT ON TABLE public.company_settings IS 'Stores settings and subscription details for each company.';

-- Enable RLS on the new columns (RLS should already be enabled on the table)
-- Note: The existing policy on company_settings will automatically cover these new columns.

-- Set a default trial expiration for existing companies that don't have one
UPDATE public.company_settings
SET subscription_expires_at = now() + interval '14 days'
WHERE subscription_expires_at IS NULL AND subscription_status = 'trialing';

-- Set default usage limits for existing companies based on their (new default) plan
UPDATE public.company_settings
SET
    usage_limits = '{"ai_queries": 1000, "skus": 5000, "users": 5}',
    current_usage = '{"ai_queries": 0, "skus": 0, "users": 0}'
WHERE
    subscription_plan = 'starter' AND usage_limits IS NULL;


-- Add a new table to track usage metrics over time
CREATE TABLE IF NOT EXISTS public.usage_metrics (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    company_id uuid NOT NULL REFERENCES public.companies(id) ON DELETE CASCADE,
    metric_type text NOT NULL, -- e.g., 'ai_queries', 'skus'
    value integer NOT NULL,
    recorded_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_usage_metrics_company_recorded_at ON public.usage_metrics(company_id, recorded_at DESC);

-- Enable RLS on the new usage_metrics table
ALTER TABLE public.usage_metrics ENABLE ROW LEVEL SECURITY;

-- Add RLS policy for the new usage_metrics table
DROP POLICY IF EXISTS "Users can manage usage metrics for their own company" ON public.usage_metrics;
CREATE POLICY "Users can manage usage metrics for their own company"
    ON public.usage_metrics
    FOR ALL
    USING (company_id = (
        SELECT company_id
        FROM public.users
        WHERE id = auth.uid()
    ));

GRANT SELECT, INSERT, UPDATE, DELETE ON public.usage_metrics TO authenticated;

-- Log that the migration has been applied
-- This is a simple way to track which migrations have run.
-- A more robust system would use a dedicated migrations table.
INSERT INTO public.audit_log(action, details) VALUES ('database_migration', '{"name": "20240701_add_billing_fields", "status": "success"}')
ON CONFLICT DO NOTHING;

-- End of migration script
