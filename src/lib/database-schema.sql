
--
-- PostgreSQL database dump
--

-- Dumped from database version 15.1
-- Dumped by pg_dump version 15.1 (Debian 15.1-1.pgdg110+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "public";


--
-- Name: pg_net; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";


--
-- Name: get_current_company_id(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE OR REPLACE FUNCTION public.get_current_company_id() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  select nullif(current_setting('request.jwt.claims', true)::jsonb ->> 'company_id', '')::uuid;
$$;


--
-- Name: get_current_user_role(); Type: FUNCTION; Schema: public; Owner: postgres
--
CREATE OR REPLACE FUNCTION public.get_current_user_role()
RETURNS text
LANGUAGE sql STABLE
AS $$
  SELECT nullif(current_setting('request.jwt.claims', true)::jsonb ->> 'role', '')::text;
$$;


--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  company_id uuid;
  company_name text;
begin
  -- Extract company_name from metadata, falling back to a default if not present
  company_name := new.raw_user_meta_data ->> 'company_name';
  if company_name is null or company_name = '' then
    company_name := 'My Company'; -- Set a default company name
  end if;

  -- Create a new company for the new user
  insert into public.companies (name)
  values (company_name)
  returning id into company_id;

  -- Insert a user record in the public users table
  insert into public.users (id, company_id, email, role)
  values (new.id, company_id, new.email, 'Owner');

  -- Update the user's app_metadata with the new company_id and role
  update auth.users
  set raw_app_meta_data = raw_app_meta_data || jsonb_build_object('company_id', company_id, 'role', 'Owner')
  where id = new.id;

  return new;
end;
$$;


--
-- Name: update_variant_quantity_from_ledger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE OR REPLACE FUNCTION public.update_variant_quantity_from_ledger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE public.product_variants
    SET inventory_quantity = (
        SELECT COALESCE(SUM(quantity_change), 0)
        FROM public.inventory_ledger
        WHERE variant_id = NEW.variant_id
    )
    WHERE id = NEW.variant_id;
    RETURN NEW;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = "heap";

--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_log (
    id bigint NOT NULL,
    user_id uuid,
    action text NOT NULL,
    details jsonb,
    created_at timestamp with time zone DEFAULT now(),
    company_id uuid
);


--
-- Name: audit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.audit_log ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.audit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: channel_fees; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.channel_fees (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    channel_name text NOT NULL,
    percentage_fee numeric NOT NULL,
    fixed_fee numeric NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone
);


--
-- Name: companies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: company_settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.company_settings (
    company_id uuid NOT NULL,
    dead_stock_days integer DEFAULT 90 NOT NULL,
    fast_moving_days integer DEFAULT 30 NOT NULL,
    predictive_stock_days integer DEFAULT 7 NOT NULL,
    currency text DEFAULT 'USD'::text,
    timezone text DEFAULT 'UTC'::text,
    tax_rate numeric DEFAULT 0,
    custom_rules jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone,
    subscription_status text DEFAULT 'trial'::text,
    subscription_plan text DEFAULT 'starter'::text,
    subscription_expires_at timestamp with time zone,
    stripe_customer_id text,
    stripe_subscription_id text,
    promo_sales_lift_multiplier real DEFAULT 2.5 NOT NULL,
    overstock_multiplier integer DEFAULT 3 NOT NULL,
    high_value_threshold integer DEFAULT 1000 NOT NULL
);


--
-- Name: conversations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.conversations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    company_id uuid NOT NULL,
    title text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    is_starred boolean DEFAULT false
);


--
-- Name: customers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    customer_name text NOT NULL,
    email text,
    total_orders integer DEFAULT 0,
    total_spent numeric DEFAULT 0,
    first_order_date date,
    deleted_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: discounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.discounts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    code text NOT NULL,
    type text NOT NULL,
    value numeric NOT NULL,
    minimum_purchase numeric,
    usage_limit integer,
    usage_count integer DEFAULT 0,
    applies_to text DEFAULT 'all'::text,
    starts_at timestamp with time zone,
    ends_at timestamp with time zone,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: export_jobs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.export_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    requested_by_user_id uuid NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    download_url text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: integrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integrations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    platform text NOT NULL,
    shop_domain text,
    shop_name text,
    is_active boolean DEFAULT false,
    last_sync_at timestamp with time zone,
    sync_status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone
);


--
-- Name: inventory_ledger; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inventory_ledger (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    change_type text NOT NULL,
    quantity_change integer NOT NULL,
    new_quantity integer NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    related_id uuid,
    notes text,
    variant_id uuid NOT NULL
);


--
-- Name: messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    conversation_id uuid NOT NULL,
    company_id uuid NOT NULL,
    role text NOT NULL,
    content text,
    component text,
    component_props jsonb,
    visualization jsonb,
    confidence numeric,
    assumptions text[],
    created_at timestamp with time zone DEFAULT now(),
    is_error boolean DEFAULT false
);


--
-- Name: orders; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    order_number text NOT NULL,
    external_order_id text,
    customer_id uuid,
    status text DEFAULT 'pending'::text NOT NULL,
    financial_status text DEFAULT 'pending'::text,
    fulfillment_status text DEFAULT 'unfulfilled'::text,
    currency text DEFAULT 'USD'::text,
    subtotal integer DEFAULT 0 NOT NULL,
    total_tax integer DEFAULT 0,
    total_shipping integer DEFAULT 0,
    total_discounts integer DEFAULT 0,
    total_amount integer NOT NULL,
    source_platform text,
    source_name text,
    tags text[],
    notes text,
    cancelled_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: product_variants; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_variants (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    product_id uuid NOT NULL,
    company_id uuid NOT NULL,
    sku text NOT NULL,
    title text,
    option1_name text,
    option1_value text,
    option2_name text,
    option2_value text,
    option3_name text,
    option3_value text,
    barcode text,
    price integer,
    compare_at_price integer,
    cost integer,
    weight numeric,
    weight_unit text,
    inventory_quantity integer DEFAULT 0,
    external_variant_id text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: products; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    title text NOT NULL,
    description text,
    handle text,
    product_type text,
    tags text[],
    status text,
    image_url text,
    external_product_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone
);


--
-- Name: order_line_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    product_id uuid,
    variant_id uuid,
    product_name text NOT NULL,
    variant_title text,
    sku text,
    quantity integer NOT NULL,
    price integer NOT NULL,
    total_discount integer DEFAULT 0,
    tax_amount integer DEFAULT 0,
    fulfillment_status text DEFAULT 'unfulfilled'::text,
    requires_shipping boolean DEFAULT true,
    external_line_item_id text,
    company_id uuid NOT NULL,
    cost_at_time integer
);


--
-- Name: suppliers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.suppliers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    default_lead_time_days integer,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id uuid NOT NULL,
    company_id uuid NOT NULL,
    email text,
    deleted_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    role text DEFAULT 'member'::text
);


--
-- Name: webhook_events; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.webhook_events (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    integration_id uuid NOT NULL,
    webhook_id text NOT NULL,
    processed_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);

--
-- Name: user_feedback; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.user_feedback (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    user_id uuid NOT NULL,
    subject_id text NOT NULL,
    subject_type text NOT NULL,
    feedback text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Add all primary key constraints
--
ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.channel_fees
    ADD CONSTRAINT channel_fees_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.companies
    ADD CONSTRAINT companies_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.company_settings
    ADD CONSTRAINT company_settings_pkey PRIMARY KEY (company_id);
ALTER TABLE ONLY public.conversations
    ADD CONSTRAINT conversations_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.discounts
    ADD CONSTRAINT discounts_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.export_jobs
    ADD CONSTRAINT export_jobs_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.integrations
    ADD CONSTRAINT integrations_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.inventory_ledger
    ADD CONSTRAINT inventory_ledger_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.suppliers
    ADD CONSTRAINT suppliers_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.webhook_events
    ADD CONSTRAINT webhook_events_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.user_feedback
    ADD CONSTRAINT user_feedback_pkey PRIMARY KEY (id);

--
-- Add all unique constraints
--
ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_company_id_external_variant_id_key UNIQUE (company_id, external_variant_id);
ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_company_id_external_product_id_key UNIQUE (company_id, external_product_id);
ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_sku_company_id_key UNIQUE (sku, company_id);
ALTER TABLE ONLY public.suppliers
    ADD CONSTRAINT suppliers_name_company_id_key UNIQUE (name, company_id);
ALTER TABLE ONLY public.webhook_events
    ADD CONSTRAINT webhook_events_webhook_id_key UNIQUE (webhook_id);

--
-- Create all indexes
--
CREATE INDEX idx_orders_company_id_created_at ON public.orders USING btree (company_id, created_at DESC);
CREATE INDEX idx_oli_order_id ON public.order_line_items USING btree (order_id);
CREATE INDEX idx_oli_variant_id ON public.order_line_items USING btree (variant_id);
CREATE INDEX idx_variants_product_id ON public.product_variants USING btree (product_id);
CREATE INDEX idx_inventory_ledger_variant_id ON public.inventory_ledger USING btree (variant_id);

--
-- Add all foreign key constraints
--
ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;
ALTER TABLE ONLY public.channel_fees
    ADD CONSTRAINT channel_fees_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.company_settings
    ADD CONSTRAINT company_settings_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.conversations
    ADD CONSTRAINT conversations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.conversations
    ADD CONSTRAINT conversations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.discounts
    ADD CONSTRAINT discounts_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.export_jobs
    ADD CONSTRAINT export_jobs_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.export_jobs
    ADD CONSTRAINT export_jobs_requested_by_user_id_fkey FOREIGN KEY (requested_by_user_id) REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.integrations
    ADD CONSTRAINT integrations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.inventory_ledger
    ADD CONSTRAINT inventory_ledger_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.inventory_ledger
    ADD CONSTRAINT inventory_ledger_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.messages
    ADD CONSTRAINT messages_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.messages
    ADD CONSTRAINT messages_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES public.conversations(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE SET NULL;
ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id) ON DELETE SET NULL;
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(id) ON DELETE SET NULL;
ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.suppliers
    ADD CONSTRAINT suppliers_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.webhook_events
    ADD CONSTRAINT webhook_events_integration_id_fkey FOREIGN KEY (integration_id) REFERENCES public.integrations(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.user_feedback
    ADD CONSTRAINT user_feedback_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.user_feedback
    ADD CONSTRAINT user_feedback_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

--
-- Name: on_auth_user_created; Type: TRIGGER; Schema: auth; Owner: postgres
--
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

--
-- Name: on_inventory_change; Type: TRIGGER; Schema: public; Owner: postgres
--
CREATE TRIGGER on_inventory_change
  AFTER INSERT ON public.inventory_ledger
  FOR EACH ROW
  EXECUTE FUNCTION public.update_variant_quantity_from_ledger();

--
-- Enable Row Level Security (RLS) for all tables
--
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.channel_fees ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.company_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.export_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.integrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.inventory_ledger ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_line_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_variants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.webhook_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_feedback ENABLE ROW LEVEL SECURITY;

--
-- Policies
--
-- Companies
DROP POLICY IF EXISTS "Allow full access based on company_id" ON public.companies;
CREATE POLICY "Allow full access based on company_id" ON public.companies FOR ALL USING (id = get_current_company_id()) WITH CHECK (id = get_current_company_id());

-- Users
DROP POLICY IF EXISTS "Allow users to view other users in their company" ON public.users;
CREATE POLICY "Allow users to view other users in their company" ON public.users FOR SELECT USING (company_id = get_current_company_id());
DROP POLICY IF EXISTS "Allow owner to manage users in their company" ON public.users;
CREATE POLICY "Allow owner to manage users in their company" ON public.users FOR ALL USING (company_id = get_current_company_id() AND get_current_user_role() = 'Owner') WITH CHECK (company_id = get_current_company_id());

-- Company Settings
DROP POLICY IF EXISTS "Allow full access based on company_id" ON public.company_settings;
CREATE POLICY "Allow full access based on company_id" ON public.company_settings FOR ALL USING (company_id = get_current_company_id()) WITH CHECK (company_id = get_current_company_id());

-- Generic "allow full access" policy for most tables
CREATE OR REPLACE FUNCTION create_company_based_policy(table_name text)
RETURNS void AS $$
BEGIN
  EXECUTE format('DROP POLICY IF EXISTS "Allow full access based on company_id" ON public.%I;', table_name);
  EXECUTE format('CREATE POLICY "Allow full access based on company_id" ON public.%I FOR ALL USING (company_id = get_current_company_id()) WITH CHECK (company_id = get_current_company_id());', table_name);
END;
$$ LANGUAGE plpgsql;

-- Apply the generic policy to all relevant tables
SELECT create_company_based_policy(table_name)
FROM information_schema.tables
WHERE table_schema = 'public' AND table_name IN (
  'products', 'product_variants', 'suppliers', 'orders', 'order_line_items', 'customers',
  'inventory_ledger', 'conversations', 'messages', 'integrations', 'discounts',
  'channel_fees', 'export_jobs', 'user_feedback', 'audit_log'
);

DROP FUNCTION create_company_based_policy(text);

-- Webhook events are special - they don't have a company_id directly
DROP POLICY IF EXISTS "Allow service role to access webhook events" ON public.webhook_events;
CREATE POLICY "Allow service role to access webhook events" ON public.webhook_events FOR ALL USING (true); -- Accessible only by service_role key

--
-- Functions that depend on the new schema
--
DROP FUNCTION IF EXISTS public.record_order_from_platform(uuid, text, jsonb);
DROP FUNCTION IF EXISTS public.record_order_from_platform(uuid, uuid, text, jsonb);
CREATE OR REPLACE FUNCTION public.record_order_from_platform(p_company_id uuid, p_user_id uuid, p_platform text, p_order_payload jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_customer_id uuid;
    v_order_id uuid;
    v_variant_id uuid;
    v_product_id uuid;
    line_item jsonb;
    v_sku text;
BEGIN
    -- 1. Find or Create Customer
    SELECT id INTO v_customer_id FROM customers WHERE email = p_order_payload -> 'billing' ->> 'email' AND company_id = p_company_id;
    IF v_customer_id IS NULL THEN
        INSERT INTO customers (company_id, customer_name, email)
        VALUES (p_company_id, 
                (p_order_payload -> 'billing' ->> 'first_name') || ' ' || (p_order_payload -> 'billing' ->> 'last_name'),
                p_order_payload -> 'billing' ->> 'email')
        RETURNING id INTO v_customer_id;
    END IF;

    -- 2. Create Order
    INSERT INTO orders (company_id, order_number, external_order_id, customer_id, financial_status, fulfillment_status, currency, subtotal, total_tax, total_shipping, total_discounts, total_amount, source_platform, created_at)
    VALUES (
        p_company_id,
        p_order_payload ->> 'number',
        p_order_payload ->> 'id',
        v_customer_id,
        p_order_payload ->> 'financial_status',
        p_order_payload ->> 'fulfillment_status',
        p_order_payload ->> 'currency',
        (p_order_payload ->> 'subtotal_price')::numeric * 100,
        (p_order_payload ->> 'total_tax')::numeric * 100,
        (p_order_payload -> 'total_shipping_price' ->> 'amount')::numeric * 100,
        (p_order_payload ->> 'total_discounts')::numeric * 100,
        (p_order_payload ->> 'total_price')::numeric * 100,
        p_platform,
        (p_order_payload ->> 'created_at')::timestamptz
    ) RETURNING id INTO v_order_id;

    -- 3. Process Line Items
    FOR line_item IN SELECT * FROM jsonb_array_elements(p_order_payload -> 'line_items')
    LOOP
        v_sku := line_item ->> 'sku';
        
        -- Find variant and product IDs
        SELECT id, product_id INTO v_variant_id, v_product_id FROM product_variants WHERE sku = v_sku AND company_id = p_company_id;

        IF v_variant_id IS NOT NULL THEN
            -- Insert line item
            INSERT INTO order_line_items (order_id, company_id, product_id, variant_id, product_name, variant_title, sku, quantity, price, external_line_item_id)
            VALUES (
                v_order_id,
                p_company_id,
                v_product_id,
                v_variant_id,
                line_item ->> 'title',
                line_item ->> 'variant_title',
                v_sku,
                (line_item ->> 'quantity')::integer,
                (line_item ->> 'price')::numeric * 100,
                line_item ->> 'id'
            );

            -- Create inventory ledger entry for the sale
            INSERT INTO inventory_ledger (company_id, variant_id, change_type, quantity_change, related_id, notes)
            VALUES (
                p_company_id,
                v_variant_id,
                'sale',
                -(line_item ->> 'quantity')::integer,
                v_order_id,
                'Order #' || (p_order_payload ->> 'number')
            );
        END IF;
    END LOOP;
    
    RETURN v_order_id;
END;
$function$;

--
-- Name: company_dashboard_metrics; Type: MATERIALIZED VIEW; Schema: public; Owner: postgres
--
DROP MATERIALIZED VIEW IF EXISTS public.company_dashboard_metrics;
CREATE MATERIALIZED VIEW public.company_dashboard_metrics AS
 SELECT c.id AS company_id,
    COALESCE(sum(o.total_amount), (0)::numeric) AS total_revenue,
    COALESCE(sum(o.total_amount - total_cost.total_cost), (0)::numeric) AS total_profit,
    (COALESCE(count(DISTINCT o.id), (0)::bigint))::integer AS total_orders,
    COALESCE(avg(o.total_amount), (0)::numeric) AS avg_order_value
   FROM ((public.companies c
     LEFT JOIN public.orders o ON ((c.id = o.company_id)))
     LEFT JOIN ( SELECT o_1.id AS order_id,
            sum(COALESCE(oli.cost_at_time, (0)::integer) * oli.quantity) AS total_cost
           FROM (public.orders o_1
             JOIN public.order_line_items oli ON ((o_1.id = oli.order_id)))
          GROUP BY o_1.id) total_cost ON ((o.id = total_cost.order_id)))
  GROUP BY c.id;

--
-- Name: get_dashboard_metrics(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--
DROP FUNCTION IF EXISTS public.get_dashboard_metrics(uuid, integer);
CREATE OR REPLACE FUNCTION public.get_dashboard_metrics(p_company_id uuid, p_days integer) RETURNS TABLE(total_sales_value numeric, total_profit numeric, average_order_value numeric, total_orders bigint, total_skus bigint, total_inventory_value numeric, dead_stock_items_count bigint, low_stock_items_count bigint, sales_trend_data jsonb, inventory_by_category_data jsonb, top_customers_data jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    date_from timestamptz := now() - (p_days || ' days')::interval;
BEGIN
    RETURN QUERY
    WITH date_series AS (
        SELECT generate_series(date_from, now(), '1 day'::interval)::date as date
    ),
    company_orders AS (
        SELECT * FROM orders WHERE company_id = p_company_id AND created_at >= date_from
    ),
    order_costs AS (
        SELECT
            o.id as order_id,
            SUM(COALESCE(oli.cost_at_time, pv.cost, 0) * oli.quantity) as total_cost
        FROM company_orders o
        JOIN order_line_items oli ON o.id = oli.order_id
        LEFT JOIN product_variants pv ON oli.variant_id = pv.id
        GROUP BY o.id
    )
    SELECT
        -- Core Metrics
        COALESCE(SUM(co.total_amount), 0)::numeric,
        (COALESCE(SUM(co.total_amount), 0) - COALESCE(SUM(oc.total_cost), 0))::numeric as total_profit,
        COALESCE(AVG(co.total_amount), 0)::numeric,
        COUNT(DISTINCT co.id)::bigint as total_orders,
        (SELECT COUNT(*) FROM product_variants WHERE company_id = p_company_id)::bigint as total_skus,
        (SELECT COALESCE(SUM(cost * inventory_quantity), 0) FROM product_variants WHERE company_id = p_company_id)::numeric as total_inventory_value,
        0::bigint as dead_stock_items_count, -- Placeholder
        0::bigint as low_stock_items_count, -- Placeholder

        -- Chart: Sales Trend
        (SELECT jsonb_agg(jsonb_build_object('date', s.date, 'Sales', s.daily_sales))
         FROM (
             SELECT
                 ds.date,
                 COALESCE(SUM(o.total_amount), 0) as daily_sales
             FROM date_series ds
             LEFT JOIN company_orders o ON o.created_at::date = ds.date
             GROUP BY ds.date
             ORDER BY ds.date
         ) s) as sales_trend_data,

        -- Chart: Inventory by Category
        (SELECT jsonb_agg(jsonb_build_object('name', COALESCE(p.product_type, 'Uncategorized'), 'value', cat.value))
         FROM (
             SELECT
                 p.product_type,
                 SUM(pv.inventory_quantity * pv.cost) as value
             FROM product_variants pv
             JOIN products p ON pv.product_id = p.id
             WHERE pv.company_id = p_company_id
             GROUP BY p.product_type
             ORDER BY value DESC
             LIMIT 5
         ) cat
         JOIN products p ON cat.product_type = p.product_type
         WHERE p.company_id = p_company_id
        ) as inventory_by_category_data,
        
        -- Chart: Top Customers
        (SELECT jsonb_agg(jsonb_build_object('name', c.customer_name, 'value', top_c.total_spent))
         FROM (
            SELECT customer_id, SUM(total_amount) as total_spent
            FROM company_orders
            WHERE customer_id IS NOT NULL
            GROUP BY customer_id
            ORDER BY total_spent DESC
            LIMIT 5
         ) top_c
         JOIN customers c ON top_c.customer_id = c.id
        ) as top_customers_data

    FROM companies c
    LEFT JOIN company_orders co ON c.id = co.company_id
    LEFT JOIN order_costs oc ON co.id = oc.order_id
    WHERE c.id = p_company_id
    GROUP BY c.id;
END;
$$;


ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;

